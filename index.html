<!DOCTYPE html>
<html lang="ja">
<head>
Â  Â  <meta charset="UTF-8">
Â  Â  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
Â  Â  <meta name="description" content="è¨ˆç®—ã§åŠ é€Ÿï¼èµ°ã‚Šç¶šã‘ã‚‹è„³ãƒˆãƒ¬ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚²ãƒ¼ãƒ  - è¨ˆç®—ç–¾èµ°ï¼RUNÃ—ç®—">
Â  Â  <title>è¨ˆç®—ç–¾èµ°ï¼RUNÃ—ç®—</title>
Â  Â  </head>
<style>
Â  Â  /* ------------------------------------------------------------- */
Â  Â  /* å…¨ä½“è¨­å®š */
Â  Â  /* ------------------------------------------------------------- */
Â  Â  body {
Â  Â  Â  Â  font-family: sans-serif;
Â  Â  Â  Â  background: #eef;
Â  Â  Â  Â  text-align: center;
Â  Â  Â  Â  margin: 0;
Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  flex-direction: column;
Â  Â  Â  Â  justify-content: center;
Â  Â  Â  Â  align-items: center;
        /* ã“ã“ã‚’èª¿æ•´ */
Â  Â  Â  Â  **height: 100vh;** /* æ¨™æº–çš„ãªãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆã®é«˜ã• */
Â  Â  Â  Â  **height: 100dvh;** /* ãƒ¢ãƒã‚¤ãƒ«ãƒ–ãƒ©ã‚¦ã‚¶ã®å‹•çš„ãªUIã‚’è€ƒæ…®ã—ãŸãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆã®é«˜ã• (æ¨å¥¨) */
Â  Â  Â  Â  width: 100vw;
Â  Â  Â  Â  overflow: hidden; /* Prevent scrolling of the entire page */
Â  Â  Â  Â  **position: fixed;** /* bodyã‚’å›ºå®šã—ã¦ä¸è¦ãªã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã¨ãƒ–ãƒ©ã‚¦ã‚¶UIã®éš è”½ã‚’åŠ©ã‘ã‚‹ */
Â  Â  Â  Â  top: 0;
Â  Â  Â  Â  left: 0;
Â  Â  }

Â  Â  /* ------------------------------------------------------------- */
Â  Â  /* ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ (Title Screen) */
Â  Â  /* ------------------------------------------------------------- */
Â  Â  #title-screen {
Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  flex-direction: column;
Â  Â  Â  Â  justify-content: center;
Â  Â  Â  Â  align-items: center;
Â  Â  Â  Â  **height: 100vh;** /* æ¨™æº–çš„ãªãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆã®é«˜ã• */
Â  Â  Â  Â  **height: 100dvh;** /* ãƒ¢ãƒã‚¤ãƒ«ãƒ–ãƒ©ã‚¦ã‚¶ã®å‹•çš„ãªUIã‚’è€ƒæ…®ã—ãŸãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆã®é«˜ã• (æ¨å¥¨) */
Â  Â  Â  Â  width: 100vw; /* Occupy full viewport width */
Â  Â  Â  Â  background-color: #e0f7fa;
Â  Â  Â  Â  position: fixed; /* Keep it fixed over the whole screen */
Â  Â  Â  Â  top: 0;
Â  Â  Â  Â  left: 0;
Â  Â  Â  Â  z-index: 2000; /* Ensure it's on top */
Â  Â  }
Â  Â  #title-screen h1 {
Â  Â  Â  Â  font-size: 4vw;
Â  Â  Â  Â  color: #333;
Â  Â  }
    /* ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ã®è¶³ã—ç®—ãƒ»å¼•ãç®—ãªã©ã®è¡¨ç¤º */
    #title-screen > div:nth-of-type(1) > div:nth-of-type(1) p {
        font-size: 2.5vw;
    }
Â  Â  #start-button, #adult-mode-button {
Â  Â  Â  Â  margin-top: 2.2vh;
Â  Â  Â  Â  padding: 1.8vh 3.5vw;
Â  Â  Â  Â  font-size: 1.8vw;
Â  Â  Â  Â  background-color: #4CAF50;
Â  Â  Â  Â  color: white;
Â  Â  Â  Â  border: none;
Â  Â  Â  Â  border-radius: 0.8vw;
Â  Â  Â  Â  cursor: pointer;
Â  Â  Â  Â  transition: background-color 0.3s;
Â  Â  }
Â  Â  #adult-mode-button {
Â  Â  Â  Â  background-color: #f44336;
Â  Â  }
Â  Â  #start-button:hover, #adult-mode-button:hover {
Â  Â  Â  Â  background-color: #45a049;
Â  Â  }

Â  Â  /* Skin selection modal */
Â  Â  #skin-select {
Â  Â  Â  Â  margin-top: 2.2vh;
Â  Â  }
Â  Â  #skin-select p {
Â  Â  Â  Â  font-size: 2vw;
Â  Â  }
Â  Â  #skin-select div {
Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  gap: 0.8vw;
Â  Â  Â  Â  margin-top: 0.8vh;
Â  Â  }
Â  Â  .skin-option {
Â  Â  Â  Â  width: 5vw;
Â  Â  Â  Â  height: 5vw;
Â  Â  Â  Â  cursor: pointer;
Â  Â  Â  Â  border: 0.2vw solid transparent;
Â  Â  Â  Â  border-radius: 0.8vw;
Â  Â  }
Â  Â  .skin-option:hover {
Â  Â  Â  Â  border-color: #4CAF50;
Â  Â  }


Â  Â  /* ------------------------------------------------------------- */
Â  Â  /* ãƒ©ãƒ³ã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ€ãƒ« (Ranking Modal) */
Â  Â  /* ------------------------------------------------------------- */
Â  Â  #ranking-modal {
Â  Â  Â  Â  display: none;
Â  Â  Â  Â  position: fixed;
Â  Â  Â  Â  top: 50%;
Â  Â  Â  Â  left: 50%;
Â  Â  Â  Â  transform: translate(-50%, -50%);
Â  Â  Â  Â  background: white;
Â  Â  Â  Â  padding: 3.5vh 3.5vw;
Â  Â  Â  Â  border: 0.2vw solid #000;
Â  Â  Â  Â  border-radius: 1.8vw;
Â  Â  Â  Â  z-index: 1000;
Â  Â  Â  Â  width: 65vw;
Â  Â  Â  Â  max-width: 380px;
Â  Â  }
Â  Â  #ranking-modal h2 {
Â  Â  Â  Â  font-size: 3vw;
Â  Â  Â  Â  margin-bottom: 1.8vh;
Â  Â  }
Â  Â  #ranking-modal p, #ranking-modal h3 {
Â  Â  Â  Â  font-size: 2vw;
Â  Â  Â  Â  margin-bottom: 0.8vh;
Â  Â  }
Â  Â  #ranking-list {
Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  flex-direction: column;
Â  Â  Â  Â  align-items: center;
Â  Â  Â  Â  justify-content: center;
Â  Â  Â  Â  padding-left: 0;
Â  Â  Â  Â  list-style: none;
Â  Â  Â  Â  margin-top: 0.8vh;
Â  Â  Â  Â  margin-bottom: 1.8vh;
Â  Â  }
Â  Â  #ranking-list li {
Â  Â  Â  Â  margin: 0.6vh 0;
Â  Â  Â  Â  font-size: 1.6vw;
Â  Â  Â  Â  font-weight: bold;
Â  Â  Â  Â  color: #333;
Â  Â  }
Â  Â  #ranking-modal button {
Â  Â  Â  Â  margin-top: 2.2vh;
Â  Â  Â  Â  padding: 1.3vh 2.8vw;
Â  Â  Â  Â  font-size: 1.8vw;
Â  Â  Â  Â  background: #4CAF50;
Â  Â  Â  Â  color: white;
Â  Â  Â  Â  border: none;
Â  Â  Â  Â  border-radius: 0.8vw;
Â  Â  Â  Â  cursor: pointer;
Â  Â  Â  Â  transition: background-color 0.3s;
Â  Â  }
Â  Â  #ranking-modal button:hover {
Â  Â  Â  Â  background: #45a049;
Â  Â  }

Â  Â  /* ------------------------------------------------------------- */
Â  Â  /* ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ (Overlay) */
Â  Â  /* ------------------------------------------------------------- */
Â  Â  #overlay {
Â  Â  Â  Â  display: none;
Â  Â  Â  Â  position: fixed;
Â  Â  Â  Â  top: 0;
Â  Â  Â  Â  left: 0;
Â  Â  Â  Â  width: 100vw;
Â  Â  Â  Â  height: 100vh;
Â  Â  Â  Â  background: rgba(0, 0, 0, 0.5);
Â  Â  Â  Â  z-index: 999; /* Below ranking modal */
Â  Â  }

Â  Â  /* ------------------------------------------------------------- */
Â  Â  /* ã‚²ãƒ¼ãƒ ç”»é¢ (Game Screen) */
Â  Â  /* ------------------------------------------------------------- */
Â  Â  #game {
Â  Â  Â  Â  position: relative;
Â  Â  Â  Â  aspect-ratio: 8 / 3; /* Maintain 800:300 ratio */
Â  Â  Â  Â  width: 80vw; /* 90vwã‹ã‚‰80vwã«ç¸®å° */
Â  Â  Â  Â  max-width: 720px; /* 800pxã‹ã‚‰720pxã«ç¸®å° (å…ƒã®90%ã«ç›¸å½“) */
Â  Â  Â  Â  
Â  Â  Â  Â  background: url('ä¸Šç©º.jpg') repeat-x center center;
Â  Â  Â  Â  background-size: cover;
Â  Â  Â  Â  border: 0.2vw solid #000;
Â  Â  Â  Â  /* margin: 1.8vh auto; */ /* ã“ã“ã‚’èª¿æ•´ */
        **margin: 0 auto;** /* ä¸Šä¸‹ã®ãƒãƒ¼ã‚¸ãƒ³ã‚’ãªãã™ */
        **max-height: 70vh;** /* ã‚²ãƒ¼ãƒ ç”»é¢ã®æœ€å¤§é«˜ã•ã‚’ç”»é¢ã®70%ã«åˆ¶é™ */
        **max-height: 70dvh;** /* å‹•çš„ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆé«˜ã•ã‚‚è€ƒæ…® */
        **box-sizing: border-box;** /* ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã¨ãƒœãƒ¼ãƒ€ãƒ¼ã‚’width/heightã«å«ã‚ã‚‹ */

Â  Â  Â  Â  overflow: hidden;
Â  Â  Â  Â  background-position: 0 0;
Â  Â  Â  Â  
Â  Â  Â  Â  display: none; /* Hidden by default, shown on game start */
Â  Â  }

Â  Â  #game.fade {
Â  Â  Â  Â  transition: opacity 0.3s ease;
Â  Â  Â  Â  opacity: 0;
Â  Â  }
Â  Â  
Â  Â  /* ------------------------------------------------------------- */
Â  Â  /* ã‚²ãƒ¼ãƒ UIè¦ç´  (Game UI Elements) */
Â  Â  /* ------------------------------------------------------------- */
Â  Â  h1 { /* "â†‘â†‘ã§ãƒ¬ãƒ¼ãƒ³ç§»å‹•ï¼ â†’ã§åŠ é€Ÿ" heading */
Â  Â  Â  Â  font-size: 2.4vw;
Â  Â  Â  Â  margin-top: 0.8vh;
Â  Â  Â  Â  margin-bottom: 0.8vh;
Â  Â  }
Â  Â  #question {
Â  Â  Â  Â  font-size: 2vw;
Â  Â  Â  Â  margin-top: 0.8vh;
Â  Â  Â  Â  margin-bottom: 0.8vh;
Â  Â  }
Â  Â  #target {
Â  Â  Â  Â  font-size: 3vw;
Â  Â  Â  Â  color: #d32f2f;
Â  Â  Â  Â  font-weight: bold;
Â  Â  Â  Â  padding: 0 0.8vw;
Â  Â  Â  Â  border-radius: 0.4vw;
Â  Â  }
Â  Â  #distance {
Â  Â  Â  Â  font-size: 1.8vw;
Â  Â  Â  Â  margin-top: 0.4vh;
Â  Â  Â  Â  margin-bottom: 0.4vh;
Â  Â  }
Â  Â  #lives {
Â  Â  Â  Â  height: 4.5vh;
Â  Â  Â  Â  font-size: 2vw;
Â  Â  Â  Â  line-height: 4.5vh;
Â  Â  Â  Â  margin-top: 0.4vh;
Â  Â  Â  Â  margin-bottom: 0.4vh;
Â  Â  }

Â  Â  /* ------------------------------------------------------------- */
Â  Â  /* ãƒ¬ãƒ¼ãƒ³ (Lanes) */
Â  Â  /* ------------------------------------------------------------- */
Â  Â  .lane {
Â  Â  Â  Â  position: absolute;
Â  Â  Â  Â  width: 100%;
Â  Â  Â  Â  height: 33.33%; /* Each lane takes 1/3 of game height */
Â  Â  Â  Â  border-top: 0.08vw solid #ccc;
Â  Â  }
Â  Â  /* Positioning lanes within the game area */
Â  Â  .lane:nth-child(1) { top: 0; }
Â  Â  .lane:nth-child(2) { top: 33.33%; }
Â  Â  .lane:nth-child(3) { top: 66.66%; }

Â  Â  /* ------------------------------------------------------------- */
Â  Â  /* ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ (Player) */
Â  Â  /* ------------------------------------------------------------- */
Â  Â  #player {
Â  Â  Â  Â  position: absolute; 
Â  Â  Â  Â  left: 6.25%;
Â  Â  Â  Â  width: 6.25%;
Â  Â  Â  Â  height: 16.67%;
Â  Â  Â  Â  background: url('type_zero_anf.gif') no-repeat center center;
Â  Â  Â  Â  background-size: 90%;
Â  Â  Â  Â  transition: top 0.1s;
Â  Â  }

Â  Â  /* ------------------------------------------------------------- */
Â  Â  /* éšœå®³ç‰© (Obstacles) */
Â  Â  /* ------------------------------------------------------------- */
Â  Â  .obstacle {
Â  Â  Â  Â  position: absolute;
Â  Â  Â  Â  width: 12.5%;
Â  Â  Â  Â  height: 16.67%;
Â  Â  Â  Â  background: rgba(173, 216, 230, 0.85);
Â  Â  Â  Â  font-size: 1.8vw;
Â  Â  Â  Â  text-align: center;
Â  Â  Â  Â  line-height: 180%;
Â  Â  Â  Â  font-weight: bold;
Â  Â  Â  Â  font-family: "Consolas", "Courier New", monospace;
Â  Â  Â  Â  transform: translateZ(0);
Â  Â  Â  Â  will-change: transform;
Â  Â  Â  Â  text-rendering: optimizeLegibility;
Â  Â  Â  Â  -webkit-font-smoothing: antialiased;
Â  Â  Â  Â  border: 0.2vw solid #007acc;
Â  Â  Â  Â  border-radius: 0.8vw;
Â  Â  Â  Â  box-shadow: 0.2vw 0.2vw 0.6vw rgba(0, 0, 0, 0.3);
Â  Â  Â  Â  color: #fff;
Â  Â  Â  Â  text-shadow: 0.1vw 0.1vw 0.2vw #000;
Â  Â  }

Â  Â  /* ------------------------------------------------------------- */
Â  Â  /* ã‚³ãƒ³ãƒœã‚²ãƒ¼ã‚¸ (Combo Bar) */
Â  Â  /* ------------------------------------------------------------- */
Â  Â  #combo-bar-container {
Â  Â  Â  Â  width: 33vw;
Â  Â  Â  Â  max-width: 270px;
Â  Â  Â  Â  height: 2.8vh;
Â  Â  Â  Â  background-color: #ccc;
Â  Â  Â  Â  border-radius: 1.2vw;
Â  Â  Â  Â  margin: 1.2vh auto;
Â  Â  Â  Â  overflow: hidden;
Â  Â  Â  Â  border: 0.2vw solid #333;
Â  Â  }
Â  Â  #combo-bar {
Â  Â  Â  Â  height: 100%;
Â  Â  Â  Â  width: 0%;
Â  Â  Â  Â  background: linear-gradient(90deg, #4CAF50, #8BC34A);
Â  Â  Â  Â  transition: width 0.2s ease;
Â  Â  }
Â  Â  @keyframes flashCombo {
Â  Â  Â  Â  0%, 100% { background-color: #4CAF50; }
Â  Â  Â  Â  50% { background-color: gold; }
Â  Â  }
Â  Â  .combo-flash {
Â  Â  Â  Â  animation: flashCombo 0.5s ease;
Â  Â  }
</style>
<body>

Â  Â  <div id="title-screen">
Â  Â  Â  Â  <h1>è¨ˆç®—ç–¾èµ°ï¼RUNÃ—ç®—</h1>
Â  Â  Â  Â  <button id="start-button">ã‚²ãƒ¼ãƒ ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
Â  Â  Â  Â  <button id="adult-mode-button">ã‚ªãƒˆãƒŠãƒ¢ãƒ¼ãƒ‰</button>
Â  Â  Â  Â  <div id="skin-select">
Â  Â  Â  Â  Â  Â  <p>ã‚¹ã‚­ãƒ³ã‚’é¸ã¼ã†ï¼</p>
Â  Â  Â  Â  Â  Â  <div>
Â  Â  Â  Â  Â  Â  Â  Â  <img src="type_zero_anf.gif" class="skin-option" onclick="selectSkin('type_zero_anf.gif')">
Â  Â  Â  Â  Â  Â  Â  Â  <img src="fighter_3body_an.gif" class="skin-option" onclick="selectSkin('fighter_3body_an.gif')">
Â  Â  Â  Â  Â  Â  Â  Â  <img src="fighter_f104_an.gif" class="skin-option" onclick="selectSkin('fighter_f104_an.gif')">
Â  Â  Â  Â  Â  Â  Â  Â  <img src="type_zero21_anf.gif" class="skin-option" onclick="selectSkin('type_zero21_anf.gif')">
Â  Â  Â  Â  Â  Â  Â  Â  <img src="helicopter_2.gif" class="skin-option" onclick="selectSkin('helicopter_2.gif')">
Â  Â  Â  Â  Â  Â  Â  Â  <img src="bird18.gif" class="skin-option" onclick="selectSkin('bird18.gif')">
Â  Â  Â  Â  Â  Â  Â  Â  <img src="karasu.gif" class="skin-option" onclick="selectSkin('karasu.gif')">
Â  Â  Â  Â  Â  Â  Â  Â  <img src="chiken.gif" class="skin-option" onclick="selectSkin('chiken.gif')">
Â  Â  Â  Â  Â  Â  Â  Â  <img src="dog.gif" class="skin-option" onclick="selectSkin('dog.gif')">
Â  Â  Â  Â  Â  Â  Â  Â  <img src="angel.gif" class="skin-option" onclick="selectSkin('angel.gif')">
Â  Â  Â  Â  Â  Â  Â  Â  <img src="ufo.gif" class="skin-option" onclick="selectSkin('ufo.gif')">
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  </div>
Â  Â  </div>
Â  Â  
Â  Â  <audio id="bgm" src="8ãƒ“ãƒƒãƒˆã®å†’é™º.mp3" loop></audio>
Â  Â  <audio id="se-correct" src="æ±ºå®šãƒœã‚¿ãƒ³ã‚’æŠ¼ã™53.mp3"></audio>
Â  Â  <audio id="se-wrong" src="ãƒ“ãƒ¼ãƒ—éŸ³4.mp3"></audio>

Â  Â  <h1>â†‘â†‘ã§ãƒ¬ãƒ¼ãƒ³ç§»å‹•ï¼ã€€â†’ã§åŠ é€Ÿ</h1>
Â  Â  <div id="question">ç­”ãˆãŒ <span id="target">?</span> ã«ãªã‚‹å¼ã‚’é¸ã¼ã†ï¼</div>
Â  Â  <div id="distance">00000m</div>
Â  Â  <div id="lives">â¤ï¸â¤ï¸â¤ï¸</div>
Â  Â  <div id="combo-bar-container">
Â  Â  Â  Â  <div id="combo-bar"></div>
Â  Â  </div>
Â  Â  <div id="game">
Â  Â  Â  Â  <div id="player"></div>
Â  Â  Â  Â  <div id="ranking-modal">
Â  Â  Â  Â  Â  Â  <h2>ğŸ GAME OVERï¼</h2>
Â  Â  Â  Â  Â  Â  <p id="final-score">ã‚ãªãŸã®ã‚¹ã‚³ã‚¢: 0</p>
Â  Â  Â  Â  Â  Â  <h3>ğŸ† ãƒ©ãƒ³ã‚­ãƒ³ã‚°</h3>
Â  Â  Â  Â  Â  Â  <ol id="ranking-list"></ol>
Â  Â  Â  Â  Â  Â  <button onclick="restartGame()">ãƒªãƒˆãƒ©ã‚¤</button>
Â  Â  Â  Â  Â  Â  <button onclick="returnToTitle()">ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ã«æˆ»ã‚‹</button>
Â  Â  Â  Â  </div>
Â  Â  </div>

Â  Â  <div id="overlay"></div>

Â  Â  <script>
Â  Â  Â  Â  const game = document.getElementById("game");
Â  Â  Â  Â  const player = document.getElementById("player");
Â  Â  Â  Â  const targetSpan = document.getElementById("target");
Â  Â  Â  Â  const livesDisplay = document.getElementById("lives");

Â  Â  Â  Â  const bgm = document.getElementById("bgm");
Â  Â  Â  Â  const seCorrect = document.getElementById("se-correct");
Â  Â  Â  Â  const seWrong = document.getElementById("se-wrong");

Â  Â  Â  Â  // ãƒ¬ãƒ¼ãƒ³ã®Yåº§æ¨™ã¯ã€ã‚²ãƒ¼ãƒ ç”»é¢ã®é«˜ã•ã«å¿œã˜ã¦å‹•çš„ã«è¨ˆç®—ã—ã¾ã™
Â  Â  Â  Â  const lanes = [0, 0, 0]; // Initial values will be set by updateLanePositions()

Â  Â  Â  Â  const backgrounds = [
Â  Â  Â  Â  Â  Â  "ä¸Šç©º.jpg", "å¤•æ–¹.jpg", "å¤œ.jpg"
Â  Â  Â  Â  ];
Â  Â  Â  Â  let backgroundIndex = 0;
Â  Â  Â  Â  let currentLane = 1;
Â  Â  Â  Â  let score = 0;
Â  Â  Â  Â  let targetAnswer = 0;
Â  Â  Â  Â  let lives = 3;
Â  Â  Â  Â  let isSpawning = false;
Â  Â  Â  Â  let hasAnswered = false;
Â  Â  Â  Â  let started = false; // BGM play flag
Â  Â  Â  Â  let isAdultMode = false;
Â  Â  Â  Â  let combo = 0;

Â  Â  Â  Â  // â–¼ èƒŒæ™¯ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ« (Background Scroll)
Â  Â  Â  Â  let bgPos = 0;
Â  Â  Â  Â  let distance = 0; // Travel distance
Â  Â  Â  Â  setInterval(() => {
Â  Â  Â  Â  Â  Â  // Adjust background movement speed based on current game width vs. original 800px
Â  Â  Â  Â  Â  Â  // This ensures consistent visual speed regardless of scaling
Â  Â  Â  Â  Â  Â  bgPos -= speed / (800 / game.offsetWidth); 
Â  Â  Â  Â  Â  Â  game.style.backgroundPosition = `${bgPos}px 0`;

Â  Â  Â  Â  Â  Â  // Add distance (proportional to speed)
Â  Â  Â  Â  Â  Â  distance += speed * 0.01;
Â  Â  Â  Â  Â  Â  const formattedDistance = Math.floor(distance).toString().padStart(5, '0') + 'm';
Â  Â  Â  Â  Â  Â  document.getElementById('distance').textContent = formattedDistance;

Â  Â  Â  Â  }, 20);

Â  Â  Â  Â  let selectedSkin = 'type_zero_anf.gif'; // Default skin
Â  Â  Â  Â  function selectSkin(skinFile) {
Â  Â  Â  Â  Â  Â  selectedSkin = skinFile;
Â  Â  Â  Â  Â  Â  player.style.backgroundImage = `url('${selectedSkin}')`;

Â  Â  Â  Â  Â  Â  // Reset all borders then apply to selected skin, using vw for border thickness
Â  Â  Â  Â  Â  Â  document.querySelectorAll('.skin-option').forEach(img => {
Â  Â  Â  Â  Â  Â  Â  Â  img.style.border = '0.2vw solid transparent';
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  const selectedImg = Array.from(document.querySelectorAll('.skin-option')).find(img => img.src.includes(skinFile));
Â  Â  Â  Â  Â  Â  if (selectedImg) {
Â  Â  Â  Â  Â  Â  Â  Â  selectedImg.style.border = '0.2vw solid #4CAF50';
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  // Game's initial speed
Â  Â  Â  Â  const INITIAL_GAME_SPEED = 2; 
Â  Â  Â  Â  let speed = INITIAL_GAME_SPEED; // Current game speed (used for obstacle movement)
Â  Â  Â  Â  let baseGameSpeed = INITIAL_GAME_SPEED; // Base game speed that permanently increases with score

Â  Â  Â  Â  // BGM's initial playback rate
Â  Â  Â  Â  const INITIAL_BGM_PLAYBACK_RATE = 1.0; 
Â  Â  Â  Â  let currentBaseBGMPlaybackRate = INITIAL_BGM_PLAYBACK_RATE; // Base BGM rate that permanently increases

Â  Â  Â  Â  let isAccelerating = false; // Flag to check if accelerating

Â  Â  Â  Â  // -------------------------------------------------------------
Â  Â  Â  Â  // ã‚¿ãƒƒãƒæ“ä½œé–¢é€£ (Touch Controls)
Â  Â  Â  Â  // -------------------------------------------------------------
Â  Â  Â  Â  let touchStartY = 0; // Stores initial Y position of touch
Â  Â  Â  Â  let touchStartX = 0; // Stores initial X position of touch
Â  Â  Â  Â  // SWIPE_THRESHOLD is an absolute pixel value; we'll convert it to be responsive
Â  Â  Â  Â  const SWIPE_THRESHOLD_ORIGINAL_PX = 50; 

Â  Â  Â  Â  const gameArea = document.getElementById("game");

Â  Â  Â  Â  if (gameArea) {
Â  Â  Â  Â  Â  Â  // Touch start event listener
Â  Â  Â  Â  Â  Â  gameArea.addEventListener("touchstart", (e) => {
Â  Â  Â  Â  Â  Â  Â  Â  touchStartY = e.touches[0].clientY;
Â  Â  Â  Â  Â  Â  Â  Â  touchStartX = e.touches[0].clientX;

Â  Â  Â  Â  Â  Â  Â  Â  if (!started) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  bgm.volume = 0.1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  bgm.play().catch(error => console.log("BGMå†ç”Ÿå¤±æ•—", error));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  started = true;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }, { passive: true });

Â  Â  Â  Â  Â  Â  // Touch move event listener
Â  Â  Â  Â  Â  Â  gameArea.addEventListener("touchmove", (e) => {
Â  Â  Â  Â  Â  Â  Â  Â  e.preventDefault(); // Prevent default browser scrolling/zooming
Â  Â  Â  Â  Â  Â  }, { passive: false }); // Needs to be false to allow preventDefault()

Â  Â  Â  Â  Â  Â  // Touch end event listener
Â  Â  Â  Â  Â  Â  gameArea.addEventListener("touchend", (e) => {
Â  Â  Â  Â  Â  Â  Â  Â  const touchEndY = e.changedTouches[0].clientY;
Â  Â  Â  Â  Â  Â  Â  Â  const touchEndX = e.changedTouches[0].clientX;

Â  Â  Â  Â  Â  Â  Â  Â  const deltaY = touchStartY - touchEndY;
Â  Â  Â  Â  Â  Â  Â  Â  const deltaX = touchEndX - touchStartX;

Â  Â  Â  Â  Â  Â  Â  Â  // Calculate responsive swipe thresholds based on game area's current dimensions
Â  Â  Â  Â  Â  Â  Â  Â  // Original game height was 300px, original width 800px.
Â  Â  Â  Â  Â  Â  Â  Â  const responsiveSwipeThresholdY = gameArea.offsetHeight * (SWIPE_THRESHOLD_ORIGINAL_PX / 300); 
Â  Â  Â  Â  Â  Â  Â  Â  const responsiveSwipeThresholdX = gameArea.offsetWidth * (SWIPE_THRESHOLD_ORIGINAL_PX / 800);

Â  Â  Â  Â  Â  Â  Â  Â  // Handle vertical swipes (lane change)
Â  Â  Â  Â  Â  Â  Â  Â  if (Math.abs(deltaY) > responsiveSwipeThresholdY && Math.abs(deltaY) > Math.abs(deltaX)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (deltaY > 0 && currentLane > 0) { // Swiped up
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  currentLane--;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (deltaY < 0 && currentLane < 2) { // Swiped down
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  currentLane++;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  player.style.top = lanes[currentLane] + "px"; // Update player position
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  // Handle horizontal swipes (accelerate/decelerate)
Â  Â  Â  Â  Â  Â  Â  Â  else if (Math.abs(deltaX) > responsiveSwipeThresholdX && Math.abs(deltaX) > Math.abs(deltaY)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (deltaX > 0 && !isAccelerating) { // Swiped right (accelerate)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  speed = baseGameSpeed * 2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  bgm.playbackRate = currentBaseBGMPlaybackRate * 2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isAccelerating = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (deltaX < 0 && isAccelerating) { // Swiped left (decelerate)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  speed = baseGameSpeed;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  bgm.playbackRate = currentBaseBGMPlaybackRate;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isAccelerating = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  }

Â  Â  Â  Â  // -------------------------------------------------------------
Â  Â  Â  Â  // ãƒ¬ãƒ¼ãƒ³ä½ç½®ã®å‹•çš„è¨ˆç®— (Dynamic Lane Position Calculation)
Â  Â  Â  Â  // -------------------------------------------------------------
Â  Â  Â  Â  function updateLanePositions() {
Â  Â  Â  Â  Â  Â  const gameHeight = game.offsetHeight; // Get current height of #game element in pixels

Â  Â  Â  Â  Â  Â  // Calculate lane Y coordinates proportionally based on original 300px game height
Â  Â  Â  Â  Â  Â  // These are pixel values for player.style.top
Â  Â  Â  Â  Â  Â  lanes[0] = gameHeight * (25 / 300); // Original top lane Y was 25px
Â  Â  Â  Â  Â  Â  lanes[1] = gameHeight * (125 / 300); // Original middle lane Y was 125px
Â  Â  Â  Â  Â  Â  lanes[2] = gameHeight * (225 / 300); // Original bottom lane Y was 225px

Â  Â  Â  Â  Â  Â  // Update player's position
Â  Â  Â  Â  Â  Â  player.style.top = lanes[currentLane] + "px";
Â  Â  Â  Â  }

Â  Â  Â  Â  // -------------------------------------------------------------
Â  Â  Â  Â  // ã‚²ãƒ¼ãƒ é–‹å§‹/ãƒªãƒˆãƒ©ã‚¤/ã‚¿ã‚¤ãƒˆãƒ«ã«æˆ»ã‚‹ (Game Start/Retry/Return to Title)
Â  Â  Â  Â  // -------------------------------------------------------------
Â  Â  Â  Â  document.getElementById("start-button").addEventListener("click", function() {
Â  Â  Â  Â  Â  Â  document.getElementById("title-screen").style.display = "none";
Â  Â  Â  Â  Â  Â  game.style.display = "block"; // Show game screen
Â  Â  Â  Â  Â  Â  updateGameLayoutAndStart();
Â  Â  Â  Â  Â  Â  isAdultMode = false;
Â  Â  Â  Â  });

Â  Â  Â  Â  document.getElementById('adult-mode-button').addEventListener('click', () => {
Â  Â  Â  Â  Â  Â  document.getElementById("title-screen").style.display = "none";
Â  Â  Â  Â  Â  Â  game.style.display = "block"; // Show game screen
Â  Â  Â  Â  Â  Â  updateGameLayoutAndStart();
Â  Â  Â  Â  Â  Â  isAdultMode = true;
Â  Â  Â  Â  });

Â  Â  Â  Â  function updateGameLayoutAndStart() {
Â  Â  Â  Â  Â  Â  updateLanePositions(); // Recalculate lane positions based on current game screen size
Â  Â  Â  Â  Â  Â  player.style.backgroundImage = `url('${selectedSkin}')`;
Â  Â  Â  Â  Â  Â  // Reset game state
Â  Â  Â  Â  Â  Â  distance = 0;
Â  Â  Â  Â  Â  Â  score = 0;
Â  Â  Â  Â  Â  Â  lives = 3;
Â  Â  Â  Â  Â  Â  combo = 0;
Â  Â  Â  Â  Â  Â  baseGameSpeed = INITIAL_GAME_SPEED;
Â  Â  Â  Â  Â  Â  speed = INITIAL_GAME_SPEED;
Â  Â  Â  Â  Â  Â  currentBaseBGMPlaybackRate = INITIAL_BGM_PLAYBACK_RATE;
Â  Â  Â  Â  Â  Â  bgm.playbackRate = INITIAL_BGM_PLAYBACK_RATE;
Â  Â  Â  Â  Â  Â  isAccelerating = false;
Â  Â  Â  Â  Â  Â  updateLivesDisplay();
Â  Â  Â  Â  Â  Â  updateComboBar();
Â  Â  Â  Â  Â  Â  game.style.backgroundImage = `url('${backgrounds[0]}')`; // Reset background
Â  Â  Â  Â  Â  Â  game.style.opacity = 1; // Ensure full opacity
Â  Â  Â  Â  Â  Â  bgm.currentTime = 0; // Reset BGM

Â  Â  Â  Â  Â  Â  // isSpawningãƒ•ãƒ©ã‚°ã‚’ç¢ºå®Ÿã«ãƒªã‚»ãƒƒãƒˆ
Â  Â  Â  Â  Â  Â  isSpawning = false; 
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // Remove all existing obstacles from the game area before starting a new round
Â  Â  Â  Â  Â  Â  document.querySelectorAll('.obstacle').forEach(obstacle => {
Â  Â  Â  Â  Â  Â  Â  Â  obstacle.remove();
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // Only play BGM if not already started by touch (for first touch case)
Â  Â  Â  Â  Â  Â  if (!started) {
Â  Â  Â  Â  Â  Â  Â  Â  bgm.volume = 0.1;
Â  Â  Â  Â  Â  Â  Â  Â  bgm.play().catch(error => console.log("BGMå†ç”Ÿå¤±æ•—", error));
Â  Â  Â  Â  Â  Â  Â  Â  started = true;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  spawnChallenge();
Â  Â  Â  Â  }


Â  Â  Â  Â  function restartGame() {
Â  Â  Â  Â  Â  Â  document.getElementById("ranking-modal").style.display = "none";
Â  Â  Â  Â  Â  Â  document.getElementById("overlay").style.display = "none"; // Hide overlay too
Â  Â  Â  Â  Â  Â  updateGameLayoutAndStart();
Â  Â  Â  Â  }

Â  Â  Â  Â  function returnToTitle() {
Â  Â  Â  Â  Â  Â  document.getElementById("ranking-modal").style.display = "none";
Â  Â  Â  Â  Â  Â  document.getElementById("overlay").style.display = "none"; // Hide overlay too
Â  Â  Â  Â  Â  Â  document.getElementById("title-screen").style.display = "flex";
Â  Â  Â  Â  Â  Â  game.style.display = "none"; // Hide game screen
Â  Â  Â  Â  Â  Â  bgm.pause(); // Stop BGM
Â  Â  Â  Â  Â  Â  started = false; // Reset BGM started flag
Â  Â  Â  Â  Â  Â  // Reset game state for next play
Â  Â  Â  Â  Â  Â  score = 0;
Â  Â  Â  Â  Â  Â  distance = 0;
Â  Â  Â  Â  Â  Â  speed = INITIAL_GAME_SPEED;
Â  Â  Â  Â  Â  Â  lives = 3;
Â  Â  Â  Â  Â  Â  combo = 0;
Â  Â  Â  Â  Â  Â  updateHearts(); // Update heart display
Â  Â  Â  Â  Â  Â  updateLivesDisplay(); // Ensure lives display is reset
Â  Â  Â  Â  Â  Â  currentLane = 1; // Reset player lane
Â  Â  Â  Â  Â  Â  updateLanePositions(); // Recalculate and set player top
Â  Â  Â  Â  Â  Â  bgPos = 0; // Reset background position
Â  Â  Â  Â  Â  Â  backgroundIndex = 0; // Reset background image
Â  Â  Â  Â  Â  Â  game.style.backgroundImage = `url('${backgrounds[backgroundIndex]}')`;
Â  Â  Â  Â  Â  Â  bgm.currentTime = 0; // Reset BGM time
Â  Â  Â  Â  Â  Â  bgm.playbackRate = INITIAL_BGM_PLAYBACK_RATE; // Reset BGM rate
Â  Â  Â  Â  Â  Â  isSpawning = false; // Allow new challenge to spawn
Â  Â  Â  Â  }

Â  Â  Â  Â  // -------------------------------------------------------------
Â  Â  Â  Â  // å¼ã‚’ãƒ©ãƒ³ãƒ€ãƒ ç”Ÿæˆ (Generate Random Expressions)
Â  Â  Â  Â  // -------------------------------------------------------------
Â  Â  Â  Â  function generateExpressions() {
Â  Â  Â  Â  Â  Â  const ops = ["+", "-", "*", "/"];
Â  Â  Â  Â  Â  Â  const expressions = [];
Â  Â  Â  Â  Â  Â  let maxNum = isAdultMode ? 50 : 9;

Â  Â  Â  Â  Â  Â  // Generate correct expression
Â  Â  Â  Â  Â  Â  let a, b, op, expr, answer;
Â  Â  Â  Â  Â  Â  do {
Â  Â  Â  Â  Â  Â  Â  Â  a = Math.floor(Math.random() * maxNum) + 1;
Â  Â  Â  Â  Â  Â  Â  Â  b = Math.floor(Math.random() * maxNum) + 1;
Â  Â  Â  Â  Â  Â  Â  Â  op = ops[Math.floor(Math.random() * ops.length)];
Â  Â  Â  Â  Â  Â  Â  Â  expr = `${a}${op}${b}`;
Â  Â  Â  Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  answer = eval(expr);
Â  Â  Â  Â  Â  Â  Â  Â  } catch (e) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  answer = NaN; 
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  // Ensure division results in an integer and answer is a finite number
Â  Â  Â  Â  Â  Â  } while ((op === "/" && a % b !== 0) || !Number.isFinite(answer));

Â  Â  Â  Â  Â  Â  targetAnswer = answer;
Â  Â  Â  Â  Â  Â  expressions.push(expr);

Â  Â  Â  Â  Â  Â  // Generate incorrect expressions
Â  Â  Â  Â  Â  Â  while (expressions.length < 3) {
Â  Â  Â  Â  Â  Â  Â  Â  let a2, b2, op2, expr2, res2;
Â  Â  Â  Â  Â  Â  Â  Â  do {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  a2 = Math.floor(Math.random() * maxNum) + 1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  b2 = Math.floor(Math.random() * maxNum) + 1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  op2 = ops[Math.floor(Math.random() * ops.length)];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  expr2 = `${a2}${op2}${b2}`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  res2 = eval(expr2);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } catch (e) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  res2 = NaN;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  } while ((op2 === "/" && a2 % b2 !== 0) || res2 === targetAnswer || !Number.isFinite(res2) || expressions.includes(expr2));
Â  Â  Â  Â  Â  Â  Â  Â  expressions.push(expr2);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  return expressions.sort(() => Math.random() - 0.5);
Â  Â  Â  Â  }

Â  Â  Â  Â  // -------------------------------------------------------------
Â  Â  Â  Â  // å•é¡Œã‚’å‡ºã™ (Spawn Challenge)
Â  Â  Â  Â  // -------------------------------------------------------------
Â  Â  Â  Â  function spawnChallenge() {
Â  Â  Â  Â  Â  Â  if (lives <= -1 || !started) return; // Prevent spawning if game over or not started
Â  Â  Â  Â  Â  Â  if (isSpawning) return;
Â  Â  Â  Â  Â  Â  isSpawning = true;
Â  Â  Â  Â  Â  Â  hasAnswered = false;

Â  Â  Â  Â  Â  Â  const expressions = generateExpressions();
Â  Â  Â  Â  Â  Â  targetSpan.textContent = targetAnswer;

Â  Â  Â  Â  Â  Â  // Find the lane for the correct answer
Â  Â  Â  Â  Â  Â  const correctLaneIndex = expressions.findIndex(e => eval(e) === targetAnswer);

Â  Â  Â  Â  Â  Â  expressions.forEach((expr, i) => {
Â  Â  Â  Â  Â  Â  Â  Â  const obstacle = document.createElement("div");
Â  Â  Â  Â  Â  Â  Â  Â  obstacle.className = "obstacle";
Â  Â  Â  Â  Â  Â  Â  Â  obstacle.textContent = expr.replace('*', 'ï½˜').replace('/', 'ï¼').replace('+', 'ï¼‹').replace('-', 'ãƒ¼');
Â  Â  Â  Â  Â  Â  Â  Â  obstacle.style.top = lanes[i] + "px"; // Set Y position based on dynamic lanes

Â  Â  Â  Â  Â  Â  Â  Â  // Obstacle starts from the right edge of the current game screen width
Â  Â  Â  Â  Â  Â  Â  Â  obstacle.style.left = game.offsetWidth + "px"; 
Â  Â  Â  Â  Â  Â  Â  Â  game.appendChild(obstacle);

Â  Â  Â  Â  Â  Â  Â  Â  let currentObstaclePos = game.offsetWidth; // Initial position based on game width
Â  Â  Â  Â  Â  Â  Â  Â  const obstacleMoveInterval = setInterval(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  currentObstaclePos -= speed; // Move obstacle based on current game speed
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  obstacle.style.left = currentObstaclePos + "px";

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const playerVisualLeft = game.offsetWidth * (50 / 800); 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const playerVisualWidth = game.offsetWidth * (50 / 800); 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const obstacleVisualWidth = game.offsetWidth * (100 / 800); 

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Check for collision: obstacle overlaps with player horizontally and is in the current lane
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  currentObstaclePos < (playerVisualLeft + playerVisualWidth * 0.8) && // Obstacle's right edge passes player's front
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  (currentObstaclePos + obstacleVisualWidth * 0.8) > playerVisualLeft && // Obstacle's left edge passes player's back
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  i === currentLane && !hasAnswered // Check if player is in the correct lane and hasn't answered yet
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  hasAnswered = true; // Mark as answered to prevent multiple hits
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  clearInterval(obstacleMoveInterval); // Stop this obstacle's movement
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (obstacle.parentNode === game) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  game.removeChild(obstacle); // Remove obstacle from DOM
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (i === correctLaneIndex) { // Correct answer
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  score++;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  combo++;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  updateComboBar();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  seCorrect.currentTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  seCorrect.volume = 0.5;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  seCorrect.play();

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Heal life every 10 combo, up to max 3
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (combo % 10 === 0 && lives < 3) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  lives++;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  updateLivesDisplay();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  updateHearts();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Combo bar flash animation
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const bar = document.getElementById("combo-bar");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  bar.classList.add("combo-flash");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  setTimeout(() => bar.classList.remove("combo-flash"), 500);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Increase game speed and BGM rate
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (score % 2 === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  baseGameSpeed += (score <= 6) ? 0.45 : (score <= 14) ? 0.38 : (score < 30) ? 0.15 : 0.1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  currentBaseBGMPlaybackRate += 0.015;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!isAccelerating) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  speed = baseGameSpeed;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  bgm.playbackRate = currentBaseBGMPlaybackRate;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Change background every 10 score
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (score % 10 === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  backgroundIndex = (backgroundIndex + 1) % backgrounds.length;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  game.style.opacity = 0; // Start fade out
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  setTimeout(() => { // Short delay before changing image
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  game.style.backgroundImage = `url('${backgrounds[backgroundIndex]}')`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  game.style.opacity = 1; // Fade in new background
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }, 300); // Match CSS transition duration
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else { // Wrong answer
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  combo = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  updateComboBar();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  lives--;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  updateLivesDisplay();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  updateHearts();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  seWrong.currentTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  seWrong.volume = 0.5;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  seWrong.play();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  flashPlayerRed();

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (lives <= -1) { // Game Over
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  fadeOutBGM();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const rankings = updateRanking(distance, isAdultMode, selectedSkin);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  showRanking(rankings);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // After an answer (correct or wrong), spawn next challenge after a delay
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isSpawning = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  spawnChallenge();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }, 4 * 1000 / baseGameSpeed); 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Remove obstacle if it goes off-screen without being hit
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (currentObstaclePos < -obstacleVisualWidth && obstacle.parentNode === game) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  clearInterval(obstacleMoveInterval);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  game.removeChild(obstacle);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // If the correct obstacle went off-screen without being answered
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!hasAnswered && i === correctLaneIndex) { 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  combo = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  updateComboBar();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  lives--;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  updateLivesDisplay();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  updateHearts();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  seWrong.currentTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  seWrong.volume = 0.5;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  seWrong.play();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  flashPlayerRed();

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (lives <= -1) { // Game Over
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  fadeOutBGM();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const rankings = updateRanking(distance, isAdultMode, selectedSkin);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  showRanking(rankings);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Spawn next challenge after missing
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isSpawning = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  spawnChallenge();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }, 4 * 1000 / baseGameSpeed); 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (!hasAnswered) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // If player hasn't answered yet and any obstacle went off-screen,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // we need to ensure the next challenge spawns eventually.
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // This case covers incorrect obstacles passing or correct ones being missed.
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isSpawning = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  spawnChallenge();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }, 4 * 1000 / baseGameSpeed); 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }, 20); // Obstacle movement interval
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  }


Â  Â  Â  Â  // -------------------------------------------------------------
Â  Â  Â  Â  // ãƒ©ã‚¤ãƒ•è¡¨ç¤º & ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ (Lives Display & Damage Effect)
Â  Â  Â  Â  // -------------------------------------------------------------
Â  Â  Â  Â  function updateLivesDisplay() {
Â  Â  Â  Â  Â  Â  livesDisplay.textContent = 'â¤ï¸'.repeat(Math.max(0, lives));
Â  Â  Â  Â  }

Â  Â  Â  Â  function updateHearts() { // Duplicate of updateLivesDisplay, kept for compatibility with existing calls
Â  Â  Â  Â  Â  Â  livesDisplay.textContent = 'â¤ï¸'.repeat(Math.max(0, lives));
Â  Â  Â  Â  }

Â  Â  Â  Â  function flashPlayerRed(times = 3, interval = 100) {
Â  Â  Â  Â  Â  Â  let count = 0;
Â  Â  Â  Â  Â  Â  const flash = () => {
Â  Â  Â  Â  Â  Â  Â  Â  // Alternates between a dark filter and no filter
Â  Â  Â  Â  Â  Â  Â  Â  player.style.filter = count % 2 === 0 ? "brightness(0.4)" : "none";
Â  Â  Â  Â  Â  Â  Â  Â  count++;
Â  Â  Â  Â  Â  Â  Â  Â  if (count < times * 2) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  setTimeout(flash, interval);
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  player.style.filter = "none"; // Ensure filter is reset at the end
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  flash();
Â  Â  Â  Â  }

Â  Â  Â  Â  // -------------------------------------------------------------
Â  Â  Â  Â  // ã‚³ãƒ³ãƒœã‚²ãƒ¼ã‚¸ (Combo Bar)
Â  Â  Â  Â  // -------------------------------------------------------------
Â  Â  Â  Â  function updateComboBar() {
Â  Â  Â  Â  Â  Â  const bar = document.getElementById("combo-bar");
Â  Â  Â  Â  Â  Â  const percentage = Math.min((combo % 10) * 10, 100); // Fills up to 100% for 10 combos
Â  Â  Â  Â  Â  Â  bar.style.width = `${percentage}%`;
Â  Â  Â  Â  }

Â  Â  Â  Â  // -------------------------------------------------------------
Â  Â  Â  Â  // ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ  (Ranking System)
Â  Â  Â  Â  // -------------------------------------------------------------
Â  Â  Â  Â  function getRankings(isAdult) {
Â  Â  Â  Â  Â  Â  const key = isAdult ? 'adultRankings' : 'normalRankings';
Â  Â  Â  Â  Â  Â  return JSON.parse(localStorage.getItem(key) || '[]');
Â  Â  Â  Â  }

Â  Â  Â  Â  function saveRankings(rankings, isAdult) {
Â  Â  Â  Â  Â  Â  const key = isAdult ? 'adultRankings' : 'normalRankings';
Â  Â  Â  Â  Â  Â  localStorage.setItem(key, JSON.stringify(rankings));
Â  Â  Â  Â  }

Â  Â  Â  Â  function updateRanking(newDistance, isAdult, playerSkin) {
Â  Â  Â  Â  Â  Â  let rankings = getRankings(isAdult);
Â  Â  Â  Â  Â  Â  // Store score as an integer to prevent floating point issues with sorting
Â  Â  Â  Â  Â  Â  rankings.push({ score: Math.floor(newDistance), skin: playerSkin }); 
Â  Â  Â  Â  Â  Â  rankings.sort((a, b) => b.score - a.score); // Sort descending by score
Â  Â  Â  Â  Â  Â  rankings = rankings.slice(0, 10); // Keep top 10 (or desired number)
Â  Â  Â  Â  Â  Â  saveRankings(rankings, isAdult);
Â  Â  Â  Â  Â  Â  return rankings;
Â  Â  Â  Â  }

Â  Â  Â  Â  function showRanking(rankings) {
Â  Â  Â  Â  Â  Â  const modal = document.getElementById("ranking-modal");
Â  Â  Â  Â  Â  Â  const finalScore = document.getElementById("final-score");
Â  Â  Â  Â  Â  Â  const rankingList = document.getElementById("ranking-list");

Â  Â  Â  Â  Â  Â  const myScore = Math.floor(distance);
Â  Â  Â  Â  Â  Â  // Find player's rank. If not found (e.g., list is empty), it will be -1.
Â  Â  Â  Â  Â  Â  const myRank = rankings.findIndex(entry => entry.score === myScore && entry.skin === selectedSkin) + 1; 
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // Adjusted final score text
Â  Â  Â  Â  Â  Â  finalScore.textContent = `ã‚ãªãŸã®ã‚¹ã‚³ã‚¢: ${myScore}m ${myRank > 0 ? `ï¼ˆ${myRank}ä½ï¼‰` : ''}`;

Â  Â  Â  Â  Â  Â  rankingList.innerHTML = ""; // Clear previous list
Â  Â  Â  Â  Â  Â  const medals = ["ğŸ¥‡", "ğŸ¥ˆ", "ğŸ¥‰"];

Â  Â  Â  Â  Â  Â  // Display top 7 or fewer if less are ranked
Â  Â  Â  Â  Â  Â  rankings.slice(0, 7).forEach((entry, i) => {
Â  Â  Â  Â  Â  Â  Â  Â  const li = document.createElement("li");
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  // Add medal or rank number
Â  Â  Â  Â  Â  Â  Â  Â  const rankText = document.createElement("span");
Â  Â  Â  Â  Â  Â  Â  Â  if (i < medals.length) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  rankText.textContent = `${medals[i]} ${entry.score}m`;
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  rankText.textContent = `${i + 1}ä½: ${entry.score}m`;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Skin image
Â  Â  Â  Â  Â  Â  Â  Â  const img = document.createElement("img");
Â  Â  Â  Â  Â  Â  Â  Â  img.src = entry.skin || "default.gif"; // Fallback in case skin is missing
Â  Â  Â  Â  Â  Â  Â  Â  img.alt = "skin";
Â  Â  Â  Â  Â  Â  Â  Â  // Scale image based on current game area width, similar to player/obstacle
Â  Â  Â  Â  Â  Â  Â  Â  img.style.width = `${game.offsetWidth * (18 / 800)}px`;
Â  Â  Â  Â  Â  Â  Â  Â  img.style.height = `${game.offsetWidth * (18 / 800)}px`;
Â  Â  Â  Â  Â  Â  Â  Â  img.style.verticalAlign = "middle";
Â  Â  Â  Â  Â  Â  Â  Â  img.style.marginLeft = `${game.offsetWidth * (4 / 800)}px`;
Â  Â  Â  Â  Â  Â  Â  Â  img.style.borderRadius = `${game.offsetWidth * (3 / 800)}px`;

Â  Â  Â  Â  Â  Â  Â  Â  li.appendChild(rankText);
Â  Â  Â  Â  Â  Â  Â  Â  li.appendChild(img);
Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  modal.style.display = "block";
Â  Â  Â  Â  Â  Â  document.getElementById("overlay").style.display = "block"; // Show overlay
Â  Â  Â  Â  }

Â  Â  Â  Â  // -------------------------------------------------------------
Â  Â  Â  Â  // BGMãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ (BGM Fade Out)
Â  Â  Â  Â  // -------------------------------------------------------------
Â  Â  Â  Â  function fadeOutBGM() {
Â  Â  Â  Â  Â  Â  let volume = bgm.volume;
Â  Â  Â  Â  Â  Â  const fade = setInterval(() => {
Â  Â  Â  Â  Â  Â  Â  Â  if (volume > 0.01) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  volume -= 0.01;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  bgm.volume = volume;
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  clearInterval(fade);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  bgm.pause();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  bgm.currentTime = 0; // Reset BGM time after fade
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  bgm.volume = 0.1; // Reset volume for next play
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }, 50);
Â  Â  Â  Â  }

Â  Â  Â  Â  // -------------------------------------------------------------
Â  Â  Â  Â  // åˆæœŸåŒ–å‡¦ç† (Initialization)
Â  Â  Â  Â  // -------------------------------------------------------------
Â  Â  Â  Â  // Initial setup on page load
Â  Â  Â  Â  document.addEventListener('DOMContentLoaded', () => {
Â  Â  Â  Â  Â  Â  selectSkin(selectedSkin); // Apply border to default skin
Â  Â  Â  Â  Â  Â  updateLivesDisplay(); // Initialize lives display
Â  Â  Â  Â  Â  Â  updateComboBar(); // Initialize combo bar
Â  Â  Â  Â  Â  Â  // updateLanePositions will be called on game start, as game.offsetHeight is 0 before display block
Â  Â  Â  Â  });

Â  Â  Â  Â  // Add a resize event listener to update lane positions
Â  Â  Â  Â  window.addEventListener('resize', () => {
Â  Â  Â  Â  Â  Â  updateLanePositions(); // Recalculate lane positions when window is resized
Â  Â  Â  Â  Â  Â  selectSkin(selectedSkin); // Reapply border for selected skin (in case vw changes affected it)
Â  Â  Â  Â  });
Â  Â  </script>
</body>
</html>
