<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="è¨ˆç®—ã§åŠ é€Ÿï¼èµ°ã‚Šç¶šã‘ã‚‹è„³ãƒˆãƒ¬ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚²ãƒ¼ãƒ  - è¨ˆç®—ç–¾èµ°ï¼RUNÃ—ç®—">
    <title>è¨ˆç®—ç–¾èµ°ï¼RUNÃ—ç®—</title>
    </head>
<style>
    /* ------------------------------------------------------------- */
    /* å…¨ä½“è¨­å®š */
    /* ------------------------------------------------------------- */
    body {
        font-family: sans-serif;
        background: #eef;
        text-align: center;
        margin: 0;
        /* Game content should be centered vertically and horizontally */
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        /*min-height: 100vh; /* Ensure body takes full viewport height */
        height: 100vh;
        height: 100dhv;
        width: 100vw;
        overflow: hidden; /* Prevent scrolling of the entire page */
        position: fixed;
        top: 0;
        left: 0;
    }

    /* ------------------------------------------------------------- */
    /* ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ (Title Screen) */
    /* ------------------------------------------------------------- */
    #title-screen {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        height: 100vh;
        width: 100vw; /* Occupy full viewport width */
        background-color: #e0f7fa;
        position: fixed; /* Keep it fixed over the whole screen */
        top: 0;
        left: 0;
        z-index: 2000; /* Ensure it's on top */
    }
    #title-screen h1 {
        font-size: 4vw; /* å¤‰æ›´: 6vwã‹ã‚‰5vwã«ç¸®å° */
        color: #333;
    }
    #start-button, #adult-mode-button {
        margin-top: 2.2vh; /* å¤‰æ›´: 2.5vhã‹ã‚‰2.2vhã«ç¸®å° */
        padding: 1.8vh 3.5vw; /* å¤‰æ›´: 2vh 4vw ã‹ã‚‰ç¸®å° */
        font-size: 1.8vw; /* å¤‰æ›´: 2.5vwã‹ã‚‰2.2vwã«ç¸®å° */
        background-color: #4CAF50;
        color: white;
        border: none;
        border-radius: 0.8vw; /* å¤‰æ›´: 1vwã‹ã‚‰0.8vwã«ç¸®å° */
        cursor: pointer;
        transition: background-color 0.3s;
    }
    #adult-mode-button {
        background-color: #f44336;
    }
    #start-button:hover, #adult-mode-button:hover {
        background-color: #45a049;
    }

    /* Skin selection modal */
    #skin-select {
        margin-top: 2.2vh; /* å¤‰æ›´: 2.5vhã‹ã‚‰2.2vhã«ç¸®å° */
    }
    #skin-select p {
        font-size: 2vw; /* å¤‰æ›´: 2.5vwã‹ã‚‰2.2vwã«ç¸®å° */
    }
    #skin-select div {
        display: flex;
        gap: 0.8vw; /* å¤‰æ›´: 1vwã‹ã‚‰0.8vwã«ç¸®å° */
        margin-top: 0.8vh; /* å¤‰æ›´: 1vhã‹ã‚‰0.8vhã«ç¸®å° */
    }
    .skin-option {
        width: 5vw; /* å¤‰æ›´: 6vwã‹ã‚‰5vwã«ç¸®å° */
        height: 5vw; /* å¤‰æ›´: 6vwã‹ã‚‰5vwã«ç¸®å° */
        cursor: pointer;
        border: 0.2vw solid transparent; /* å¤‰æ›´: 0.25vwã‹ã‚‰0.2vwã«ç¸®å° */
        border-radius: 0.8vw; /* å¤‰æ›´: 1vwã‹ã‚‰0.8vwã«ç¸®å° */
    }
    .skin-option:hover {
        border-color: #4CAF50;
    }


    /* ------------------------------------------------------------- */
    /* ãƒ©ãƒ³ã‚­ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ€ãƒ« (Ranking Modal) */
    /* ------------------------------------------------------------- */
    #ranking-modal {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        padding: 3.5vh 3.5vw; /* å¤‰æ›´: 4vh 4vw ã‹ã‚‰ç¸®å° */
        border: 0.2vw solid #000; /* å¤‰æ›´: 0.25vwã‹ã‚‰0.2vwã«ç¸®å° */
        border-radius: 1.8vw; /* å¤‰æ›´: 2vwã‹ã‚‰1.8vwã«ç¸®å° */
        z-index: 1000;
        width: 65vw; /* å¤‰æ›´: 70vwã‹ã‚‰65vwã«ç¸®å° */
        max-width: 380px; /* å¤‰æ›´: 400pxã‹ã‚‰380pxã«ç¸®å° */
    }
    #ranking-modal h2 {
        font-size: 3vw; /* å¤‰æ›´: 4vwã‹ã‚‰3.5vwã«ç¸®å° */
        margin-bottom: 1.8vh; /* å¤‰æ›´: 2vhã‹ã‚‰1.8vhã«ç¸®å° */
    }
    #ranking-modal p, #ranking-modal h3 {
        font-size: 2vw; /* å¤‰æ›´: 2.5vwã‹ã‚‰2.2vwã«ç¸®å° */
        margin-bottom: 0.8vh; /* å¤‰æ›´: 1vhã‹ã‚‰0.8vhã«ç¸®å° */
    }
    #ranking-list {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding-left: 0;
        list-style: none;
        margin-top: 0.8vh;
        margin-bottom: 1.8vh;
    }
    #ranking-list li {
        margin: 0.6vh 0; /* å¤‰æ›´: 0.8vhã‹ã‚‰0.6vhã«ç¸®å° */
        font-size: 1.6vw; /* å¤‰æ›´: 2vwã‹ã‚‰1.8vwã«ç¸®å° */
        font-weight: bold;
        color: #333;
    }
    #ranking-modal button {
        margin-top: 2.2vh; /* å¤‰æ›´: 2.5vhã‹ã‚‰2.2vhã«ç¸®å° */
        padding: 1.3vh 2.8vw; /* å¤‰æ›´: 1.5vh 3vw ã‹ã‚‰ç¸®å° */
        font-size: 1.8vw; /* å¤‰æ›´: 2.2vwã‹ã‚‰2vwã«ç¸®å° */
        background: #4CAF50;
        color: white;
        border: none;
        border-radius: 0.8vw; /* å¤‰æ›´: 1vwã‹ã‚‰0.8vwã«ç¸®å° */
        cursor: pointer;
        transition: background-color 0.3s;
    }
    #ranking-modal button:hover {
        background: #45a049;
    }

    /* ------------------------------------------------------------- */
    /* ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ (Overlay) */
    /* ------------------------------------------------------------- */
    #overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.5);
        z-index: 999; /* Below ranking modal */
    }

    /* ------------------------------------------------------------- */
    /* ã‚²ãƒ¼ãƒ ç”»é¢ (Game Screen) */
    /* ------------------------------------------------------------- */
    #game {
        position: relative;
        aspect-ratio: 8 / 3; /* Maintain 800:300 ratio */
        width: 80vw; /* â˜…å¤‰æ›´ç‚¹1â˜… 90vwã‹ã‚‰80vwã«ç¸®å° */
        max-width: 720px; /* â˜…å¤‰æ›´ç‚¹2â˜… 800pxã‹ã‚‰720pxã«ç¸®å° (å…ƒã®90%ã«ç›¸å½“) */
        
        background: url('ä¸Šç©º.jpg') repeat-x center center;
        background-size: cover;
        border: 0.2vw solid #000; /* å¤‰æ›´: 0.25vwã‹ã‚‰0.2vwã«ç¸®å° */
        margin: 0 auto; /* å¤‰æ›´: 2vhã‹ã‚‰1.8vhã«ç¸®å° */
        max-height: 70vh;
        max-height: 70dvh;
        box-sizing: border-box;
        overflow: hidden;
        background-position: 0 0;
        
        display: none; /* Hidden by default, shown on game start */
    }

    #game.fade {
        transition: opacity 0.3s ease;
        opacity: 0;
    }
    
    /* ------------------------------------------------------------- */
    /* ã‚²ãƒ¼ãƒ UIè¦ç´  (Game UI Elements) */
    /* ------------------------------------------------------------- */
    h1 { /* "â†‘â†‘ã§ãƒ¬ãƒ¼ãƒ³ç§»å‹•ï¼ â†’ã§åŠ é€Ÿ" heading */
        font-size: 2.4vw; /* å¤‰æ›´: 3vwã‹ã‚‰2.8vwã«ç¸®å° */
        margin-top: 0.4vh; /* å¤‰æ›´: 1vhã‹ã‚‰0.8vhã«ç¸®å° */
        margin-bottom: 0.4vh; /* å¤‰æ›´: 1vhã‹ã‚‰0.8vhã«ç¸®å° */
    }
    #question {
        font-size: 2vw; /* å¤‰æ›´: 3vwã‹ã‚‰2.8vwã«ç¸®å° */
        margin-top: 0.4vh; /* å¤‰æ›´: 1vhã‹ã‚‰0.8vhã«ç¸®å° */
        margin-bottom: 0.4vh; /* å¤‰æ›´: 1vhã‹ã‚‰0.8vhã«ç¸®å° */
    }
    #target {
        font-size: 3vw; /* å¤‰æ›´: 4.5vwã‹ã‚‰4vwã«ç¸®å° */
        color: #d32f2f;
        font-weight: bold;
        padding: 0 0.4vw; /* å¤‰æ›´: 1vwã‹ã‚‰0.8vwã«ç¸®å° */
        border-radius: 0.2vw; /* å¤‰æ›´: 0.5vwã‹ã‚‰0.4vwã«ç¸®å° */
    }
    #distance {
        font-size: 1.8vw; /* å¤‰æ›´: 2.5vwã‹ã‚‰2.2vwã«ç¸®å° */
        margin-top: 0.4vh; /* å¤‰æ›´: 0.5vhã‹ã‚‰0.4vhã«ç¸®å° */
        margin-bottom: 0.4vh; /* å¤‰æ›´: 0.5vhã‹ã‚‰0.4vhã«ç¸®å° */
    }
    #lives {
        height: 4.5vh; /* å¤‰æ›´: 5vhã‹ã‚‰4.5vhã«ç¸®å° */
        font-size: 2vw; /* å¤‰æ›´: 3.5vwã‹ã‚‰3.2vwã«ç¸®å° */
        line-height: 4.5vh; /* Match height for vertical centering */
        margin-top: 0.4vh; /* å¤‰æ›´: 0.5vhã‹ã‚‰0.4vhã«ç¸®å° */
        margin-bottom: 0.4vh; /* å¤‰æ›´: 0.5vhã‹ã‚‰0.4vhã«ç¸®å° */
    }

    /* ------------------------------------------------------------- */
    /* ãƒ¬ãƒ¼ãƒ³ (Lanes) */
    /* ------------------------------------------------------------- */
    .lane {
        position: absolute;
        width: 100%;
        height: 33.33%; /* Each lane takes 1/3 of game height */
        border-top: 0.08vw solid #ccc; /* å¤‰æ›´: 0.1vwã‹ã‚‰0.08vwã«ç¸®å° */
    }
    /* Positioning lanes within the game area */
    .lane:nth-child(1) { top: 0; }
    .lane:nth-child(2) { top: 33.33%; }
    .lane:nth-child(3) { top: 66.66%; }

    /* ------------------------------------------------------------- */
    /* ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ (Player) */
    /* ------------------------------------------------------------- */
    #player {
        position: absolute; 
        left: 6.25%; /* 50px / 800px = 6.25% of game width */
        width: 6.25%; /* 50px / 800px = 6.25% of game width */
        height: 16.67%; /* 50px / 300px = ~16.67% of game height */
        background: url('type_zero_anf.gif') no-repeat center center;
        background-size: 90%; /* Keep GIF scaled within player div */
        transition: top 0.1s;
    }

    /* ------------------------------------------------------------- */
    /* éšœå®³ç‰© (Obstacles) */
    /* ------------------------------------------------------------- */
    .obstacle {
        position: absolute;
        width: 12.5%; /* 100px / 800px = 12.5% of game width */
        height: 16.67%; /* 50px / 300px = ~16.67% of game height */
        background: rgba(173, 216, 230, 0.85);
        font-size: 1.8vw; /* å¤‰æ›´: 2.75vwã‹ã‚‰2.5vwã«ç¸®å° */
        text-align: center;
        line-height: 180%; /* Vertical align text within obstacle height */
        font-weight: bold;
        font-family: "Consolas", "Courier New", monospace;
        transform: translateZ(0);
        will-change: transform;
        text-rendering: optimizeLegibility;
        -webkit-font-smoothing: antialiased;
        border: 0.2vw solid #007acc; /* å¤‰æ›´: 0.25vwã‹ã‚‰0.2vwã«ç¸®å° */
        border-radius: 0.8vw; /* å¤‰æ›´: 1vwã‹ã‚‰0.8vwã«ç¸®å° */
        box-shadow: 0.2vw 0.2vw 0.6vw rgba(0, 0, 0, 0.3); /* å¤‰æ›´: 0.25vw 0.25vw 0.75vw ã‹ã‚‰ç¸®å° */
        color: #fff;
        text-shadow: 0.1vw 0.1vw 0.2vw #000; /* å¤‰æ›´: 0.125vw 0.125vw 0.25vw ã‹ã‚‰ç¸®å° */
    }

    /* ------------------------------------------------------------- */
    /* ã‚³ãƒ³ãƒœã‚²ãƒ¼ã‚¸ (Combo Bar) */
    /* ------------------------------------------------------------- */
    #combo-bar-container {
        width: 33vw; /* å¤‰æ›´: 37.5vwã‹ã‚‰33vwã«ç¸®å° */
        max-width: 270px; /* å¤‰æ›´: 300pxã‹ã‚‰270pxã«ç¸®å° */
        height: 2.8vh; /* å¤‰æ›´: 3.125vhã‹ã‚‰2.8vhã«ç¸®å° */
        background-color: #ccc;
        border-radius: 1.2vw; /* å¤‰æ›´: 1.5vwã‹ã‚‰1.2vwã«ç¸®å° */
        margin: 1.2vh auto; /* å¤‰æ›´: 1.5vhã‹ã‚‰1.2vhã«ç¸®å° */
        overflow: hidden;
        border: 0.2vw solid #333; /* å¤‰æ›´: 0.25vwã‹ã‚‰0.2vwã«ç¸®å° */
    }
    #combo-bar {
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, #4CAF50, #8BC34A);
        transition: width 0.2s ease;
    }
    @keyframes flashCombo {
        0%, 100% { background-color: #4CAF50; }
        50% { background-color: gold; }
    }
    .combo-flash {
        animation: flashCombo 0.5s ease;
    }
</style>
<body>

    <div id="title-screen">
        <h1>è¨ˆç®—ç–¾èµ°ï¼RUNÃ—ç®—</h1>
        <button id="start-button">ã‚²ãƒ¼ãƒ ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
        <button id="adult-mode-button">ã‚ªãƒˆãƒŠãƒ¢ãƒ¼ãƒ‰</button>
        <div id="skin-select">
            <p>ã‚¹ã‚­ãƒ³ã‚’é¸ã¼ã†ï¼</p>
            <div>
                <img src="type_zero_anf.gif" class="skin-option" onclick="selectSkin('type_zero_anf.gif')">
                <img src="fighter_3body_an.gif" class="skin-option" onclick="selectSkin('fighter_3body_an.gif')">
                <img src="fighter_f104_an.gif" class="skin-option" onclick="selectSkin('fighter_f104_an.gif')">
                <img src="type_zero21_anf.gif" class="skin-option" onclick="selectSkin('type_zero21_anf.gif')">
                <img src="helicopter_2.gif" class="skin-option" onclick="selectSkin('helicopter_2.gif')">
                <img src="bird18.gif" class="skin-option" onclick="selectSkin('bird18.gif')">
                <img src="karasu.gif" class="skin-option" onclick="selectSkin('karasu.gif')">
                <img src="chiken.gif" class="skin-option" onclick="selectSkin('chiken.gif')">
                <img src="dog.gif" class="skin-option" onclick="selectSkin('dog.gif')">
                <img src="angel.gif" class="skin-option" onclick="selectSkin('angel.gif')">
                <img src="ufo.gif" class="skin-option" onclick="selectSkin('ufo.gif')">
            </div>
        </div>
    </div>
    
    <audio id="bgm" src="8ãƒ“ãƒƒãƒˆã®å†’é™º.mp3" loop></audio>
    <audio id="se-correct" src="æ±ºå®šãƒœã‚¿ãƒ³ã‚’æŠ¼ã™53.mp3"></audio>
    <audio id="se-wrong" src="ãƒ“ãƒ¼ãƒ—éŸ³4.mp3"></audio>

    <h1>â†‘â†‘ã§ãƒ¬ãƒ¼ãƒ³ç§»å‹•ï¼ã€€â†’ã§åŠ é€Ÿ</h1>
    <div id="question">ç­”ãˆãŒ <span id="target">?</span> ã«ãªã‚‹å¼ã‚’é¸ã¼ã†ï¼</div>
    <div id="distance">00000m</div>
    <div id="lives">â¤ï¸â¤ï¸â¤ï¸</div>
    <div id="combo-bar-container">
        <div id="combo-bar"></div>
    </div>
    <div id="game">
        <div id="player"></div>
        <div id="ranking-modal">
            <h2>ğŸ GAME OVERï¼</h2>
            <p id="final-score">ã‚ãªãŸã®ã‚¹ã‚³ã‚¢: 0</p>
            <h3>ğŸ† ãƒ©ãƒ³ã‚­ãƒ³ã‚°</h3>
            <ol id="ranking-list"></ol>
            <button onclick="restartGame()">ãƒªãƒˆãƒ©ã‚¤</button>
            <button onclick="returnToTitle()">ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ã«æˆ»ã‚‹</button>
        </div>
    </div>

    <div id="overlay"></div>

    <script>
        const game = document.getElementById("game");
        const player = document.getElementById("player");
        const targetSpan = document.getElementById("target");
        const livesDisplay = document.getElementById("lives");

        const bgm = document.getElementById("bgm");
        const seCorrect = document.getElementById("se-correct");
        const seWrong = document.getElementById("se-wrong");

        // ãƒ¬ãƒ¼ãƒ³ã®Yåº§æ¨™ã¯ã€ã‚²ãƒ¼ãƒ ç”»é¢ã®é«˜ã•ã«å¿œã˜ã¦å‹•çš„ã«è¨ˆç®—ã—ã¾ã™
        const lanes = [0, 0, 0]; // Initial values will be set by updateLanePositions()

        const backgrounds = [
            "ä¸Šç©º.jpg", "å¤•æ–¹.jpg", "å¤œ.jpg"
        ];
        let backgroundIndex = 0;
        let currentLane = 1;
        let score = 0;
        let targetAnswer = 0;
        let lives = 3;
        let isSpawning = false;
        let hasAnswered = false;
        let started = false; // BGM play flag
        let isAdultMode = false;
        let combo = 0;

        // â–¼ èƒŒæ™¯ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ« (Background Scroll)
        let bgPos = 0;
        let distance = 0; // Travel distance
        setInterval(() => {
            // Adjust background movement speed based on current game width vs. original 800px
            // This ensures consistent visual speed regardless of scaling
            bgPos -= speed / (800 / game.offsetWidth); 
            game.style.backgroundPosition = `${bgPos}px 0`;

            // Add distance (proportional to speed)
            distance += speed * 0.01;
            const formattedDistance = Math.floor(distance).toString().padStart(5, '0') + 'm';
            document.getElementById('distance').textContent = formattedDistance;

        }, 20);

        let selectedSkin = 'type_zero_anf.gif'; // Default skin
        function selectSkin(skinFile) {
            selectedSkin = skinFile;
            player.style.backgroundImage = `url('${selectedSkin}')`;

            // Reset all borders then apply to selected skin, using vw for border thickness
            document.querySelectorAll('.skin-option').forEach(img => {
                img.style.border = '0.2vw solid transparent'; // å¤‰æ›´: 0.25vwã‹ã‚‰0.2vwã«ç¸®å°
            });
            const selectedImg = Array.from(document.querySelectorAll('.skin-option')).find(img => img.src.includes(skinFile));
            if (selectedImg) {
                selectedImg.style.border = '0.2vw solid #4CAF50'; // å¤‰æ›´: 0.25vwã‹ã‚‰0.2vwã«ç¸®å°
            }
        }

        // Game's initial speed
        const INITIAL_GAME_SPEED = 2; 
        let speed = INITIAL_GAME_SPEED; // Current game speed (used for obstacle movement)
        let baseGameSpeed = INITIAL_GAME_SPEED; // Base game speed that permanently increases with score

        // BGM's initial playback rate
        const INITIAL_BGM_PLAYBACK_RATE = 1.0; 
        let currentBaseBGMPlaybackRate = INITIAL_BGM_PLAYBACK_RATE; // Base BGM rate that permanently increases

        let isAccelerating = false; // Flag to check if accelerating

        // -------------------------------------------------------------
        // ã‚¿ãƒƒãƒæ“ä½œé–¢é€£ (Touch Controls)
        // -------------------------------------------------------------
        let touchStartY = 0; // Stores initial Y position of touch
        let touchStartX = 0; // Stores initial X position of touch
        // SWIPE_THRESHOLD is an absolute pixel value; we'll convert it to be responsive
        const SWIPE_THRESHOLD_ORIGINAL_PX = 50; 

        const gameArea = document.getElementById("game");

        if (gameArea) {
            // Touch start event listener
            gameArea.addEventListener("touchstart", (e) => {
                touchStartY = e.touches[0].clientY;
                touchStartX = e.touches[0].clientX;

                if (!started) {
                    bgm.volume = 0.1;
                    bgm.play().catch(error => console.log("BGMå†ç”Ÿå¤±æ•—", error));
                    started = true;
                    bgm.playbackRate = INITIAL_BGM_PLAYBACK_RATE;
                }
            }, { passive: true });

            // Touch move event listener
            gameArea.addEventListener("touchmove", (e) => {
                e.preventDefault(); // Prevent default browser scrolling/zooming
            }, { passive: false }); // Needs to be false to allow preventDefault()

            // Touch end event listener
            gameArea.addEventListener("touchend", (e) => {
                const touchEndY = e.changedTouches[0].clientY;
                const touchEndX = e.changedTouches[0].clientX;

                const deltaY = touchStartY - touchEndY;
                const deltaX = touchEndX - touchStartX;

                // Calculate responsive swipe thresholds based on game area's current dimensions
                // Original game height was 300px, original width 800px.
                const responsiveSwipeThresholdY = gameArea.offsetHeight * (SWIPE_THRESHOLD_ORIGINAL_PX / 300); 
                const responsiveSwipeThresholdX = gameArea.offsetWidth * (SWIPE_THRESHOLD_ORIGINAL_PX / 800);

                // Handle vertical swipes (lane change)
                if (Math.abs(deltaY) > responsiveSwipeThresholdY && Math.abs(deltaY) > Math.abs(deltaX)) {
                    if (deltaY > 0 && currentLane > 0) { // Swiped up
                        currentLane--;
                    } else if (deltaY < 0 && currentLane < 2) { // Swiped down
                        currentLane++;
                    }
                    player.style.top = lanes[currentLane] + "px"; // Update player position
                }
                // Handle horizontal swipes (accelerate/decelerate)
                else if (Math.abs(deltaX) > responsiveSwipeThresholdX && Math.abs(deltaX) > Math.abs(deltaY)) {
                    if (deltaX > 0 && !isAccelerating) { // Swiped right (accelerate)
                        speed = baseGameSpeed * 2;
                        bgm.playbackRate = currentBaseBGMPlaybackRate * 2;
                        isAccelerating = true;
                    } else if (deltaX < 0 && isAccelerating) { // Swiped left (decelerate)
                        speed = baseGameSpeed;
                        bgm.playbackRate = currentBaseBGMPlaybackRate;
                        isAccelerating = false;
                    }
                }
            });
        }

        // -------------------------------------------------------------
        // ãƒ¬ãƒ¼ãƒ³ä½ç½®ã®å‹•çš„è¨ˆç®— (Dynamic Lane Position Calculation)
        // -------------------------------------------------------------
        function updateLanePositions() {
            const gameHeight = game.offsetHeight; // Get current height of #game element in pixels

            // Calculate lane Y coordinates proportionally based on original 300px game height
            // These are pixel values for player.style.top
            lanes[0] = gameHeight * (25 / 300); // Original top lane Y was 25px
            lanes[1] = gameHeight * (125 / 300); // Original middle lane Y was 125px
            lanes[2] = gameHeight * (225 / 300); // Original bottom lane Y was 225px

            // Update player's position
            player.style.top = lanes[currentLane] + "px";
        }

        // -------------------------------------------------------------
        // ã‚²ãƒ¼ãƒ é–‹å§‹/ãƒªãƒˆãƒ©ã‚¤/ã‚¿ã‚¤ãƒˆãƒ«ã«æˆ»ã‚‹ (Game Start/Retry/Return to Title)
        // -------------------------------------------------------------
        document.getElementById("start-button").addEventListener("click", function() {
            document.getElementById("title-screen").style.display = "none";
            game.style.display = "block"; // Show game screen
            updateGameLayoutAndStart();
            isAdultMode = false;
        });

        document.getElementById('adult-mode-button').addEventListener('click', () => {
            document.getElementById("title-screen").style.display = "none";
            game.style.display = "block"; // Show game screen
            updateGameLayoutAndStart();
            isAdultMode = true;
        });

        function updateGameLayoutAndStart() {
            updateLanePositions(); // Recalculate lane positions based on current game screen size
            player.style.backgroundImage = `url('${selectedSkin}')`;
            // Reset game state
            distance = 0;
            score = 0;
            lives = 3;
            combo = 0;
            baseGameSpeed = INITIAL_GAME_SPEED;
            speed = INITIAL_GAME_SPEED;
            currentBaseBGMPlaybackRate = INITIAL_BGM_PLAYBACK_RATE;
            bgm.playbackRate = INITIAL_BGM_PLAYBACK_RATE;
            isAccelerating = false;
            updateLivesDisplay();
            updateComboBar();
            game.style.backgroundImage = `url('${backgrounds[0]}')`; // Reset background
            game.style.opacity = 1; // Ensure full opacity
            bgm.currentTime = 0; // Reset BGM

            // â˜…è¿½åŠ : ã“ã“ã§isSpawningã‚’ç¢ºå®Ÿã«falseã«ãƒªã‚»ãƒƒãƒˆã—ã¾ã™â˜…
            isSpawning = false; 
            
            // Remove all existing obstacles from the game area before starting a new round
            document.querySelectorAll('.obstacle').forEach(obstacle => {
                obstacle.remove();
            });
            
            // Only play BGM if not already started by touch (for first touch case)
            if (!started) {
                bgm.volume = 0.1;
                bgm.play().catch(error => console.log("BGMå†ç”Ÿå¤±æ•—", error));
                started = true;
            }
            spawnChallenge();
        }


        function restartGame() {
            document.getElementById("ranking-modal").style.display = "none";
            document.getElementById("overlay").style.display = "none"; // Hide overlay too
            updateGameLayoutAndStart();
        }

        function returnToTitle() {
            document.getElementById("ranking-modal").style.display = "none";
            document.getElementById("overlay").style.display = "none"; // Hide overlay too
            document.getElementById("title-screen").style.display = "flex";
            game.style.display = "none"; // Hide game screen
            bgm.pause(); // Stop BGM
            started = false; // Reset BGM started flag
            // Reset game state for next play
            score = 0;
            distance = 0;
            speed = INITIAL_GAME_SPEED;
            lives = 3;
            combo = 0;
            updateHearts(); // Update heart display
            updateLivesDisplay(); // Ensure lives display is reset
            currentLane = 1; // Reset player lane
            updateLanePositions(); // Recalculate and set player top
            bgPos = 0; // Reset background position
            backgroundIndex = 0; // Reset background image
            game.style.backgroundImage = `url('${backgrounds[backgroundIndex]}')`;
            bgm.currentTime = 0; // Reset BGM time
            bgm.playbackRate = INITIAL_BGM_PLAYBACK_RATE; // Reset BGM rate
            isSpawning = false; // Allow new challenge to spawn
        }

        // -------------------------------------------------------------
        // å¼ã‚’ãƒ©ãƒ³ãƒ€ãƒ ç”Ÿæˆ (Generate Random Expressions)
        // -------------------------------------------------------------
        function generateExpressions() {
            const ops = ["+", "-", "*", "/"];
            const expressions = [];
            let maxNum = isAdultMode ? 50 : 9;

            // Generate correct expression
            let a, b, op, expr, answer;
            do {
                a = Math.floor(Math.random() * maxNum) + 1;
                b = Math.floor(Math.random() * maxNum) + 1;
                op = ops[Math.floor(Math.random() * ops.length)];
                expr = `${a}${op}${b}`;
                try {
                    answer = eval(expr);
                } catch (e) {
                    answer = NaN; 
                }
                // Ensure division results in an integer and answer is a finite number
            } while ((op === "/" && a % b !== 0) || !Number.isFinite(answer));

            targetAnswer = answer;
            expressions.push(expr);

            // Generate incorrect expressions
            while (expressions.length < 3) {
                let a2, b2, op2, expr2, res2;
                do {
                    a2 = Math.floor(Math.random() * maxNum) + 1;
                    b2 = Math.floor(Math.random() * maxNum) + 1;
                    op2 = ops[Math.floor(Math.random() * ops.length)];
                    expr2 = `${a2}${op2}${b2}`;
                    try {
                        res2 = eval(expr2);
                    } catch (e) {
                        res2 = NaN;
                    }
                } while ((op2 === "/" && a2 % b2 !== 0) || res2 === targetAnswer || !Number.isFinite(res2) || expressions.includes(expr2));
                expressions.push(expr2);
            }
            return expressions.sort(() => Math.random() - 0.5);
        }

        // -------------------------------------------------------------
        // å•é¡Œã‚’å‡ºã™ (Spawn Challenge)
        // -------------------------------------------------------------
        function spawnChallenge() {
            if (lives <= -1 || !started) return; // Prevent spawning if game over or not started
            if (isSpawning) return;
            isSpawning = true;
            hasAnswered = false;

            const expressions = generateExpressions();
            targetSpan.textContent = targetAnswer;

            // Find the lane for the correct answer
            const correctLaneIndex = expressions.findIndex(e => eval(e) === targetAnswer);

            expressions.forEach((expr, i) => {
                const obstacle = document.createElement("div");
                obstacle.className = "obstacle";
                obstacle.textContent = expr.replace('*', 'ï½˜').replace('/', 'ï¼').replace('+', 'ï¼‹').replace('-', 'ãƒ¼');
                obstacle.style.top = lanes[i] + "px"; // Set Y position based on dynamic lanes

                // Obstacle starts from the right edge of the current game screen width
                obstacle.style.left = game.offsetWidth + "px"; 
                game.appendChild(obstacle);

                let currentObstaclePos = game.offsetWidth; // Initial position based on game width
                const obstacleMoveInterval = setInterval(() => {
                    currentObstaclePos -= speed; // Move obstacle based on current game speed
                    obstacle.style.left = currentObstaclePos + "px";

                    const playerVisualLeft = game.offsetWidth * (50 / 800); 
                    const playerVisualWidth = game.offsetWidth * (50 / 800); 
                    const obstacleVisualWidth = game.offsetWidth * (100 / 800); 

                    // Check for collision: obstacle overlaps with player horizontally and is in the current lane
                    if (
                        currentObstaclePos < (playerVisualLeft + playerVisualWidth * 0.8) && // Obstacle's right edge passes player's front
                        (currentObstaclePos + obstacleVisualWidth * 0.8) > playerVisualLeft && // Obstacle's left edge passes player's back
                        i === currentLane && !hasAnswered // Check if player is in the correct lane and hasn't answered yet
                    ) {
                        hasAnswered = true; // Mark as answered to prevent multiple hits
                        clearInterval(obstacleMoveInterval); // Stop this obstacle's movement
                        if (obstacle.parentNode === game) {
                            game.removeChild(obstacle); // Remove obstacle from DOM
                        }

                        if (i === correctLaneIndex) { // Correct answer
                            score++;
                            combo++;
                            updateComboBar();
                            seCorrect.currentTime = 0;
                            seCorrect.volume = 0.5;
                            seCorrect.play();

                            // Heal life every 10 combo, up to max 3
                            if (combo % 10 === 0 && lives < 3) {
                                lives++;
                                updateLivesDisplay();
                                updateHearts();
                                // Combo bar flash animation
                                const bar = document.getElementById("combo-bar");
                                bar.classList.add("combo-flash");
                                setTimeout(() => bar.classList.remove("combo-flash"), 500);
                            }

                            // Increase game speed and BGM rate
                            if (score % 2 === 0) {
                                baseGameSpeed += (score <= 6) ? 0.45 : (score <= 14) ? 0.38 : (score < 30) ? 0.15 : 0.1;
                                currentBaseBGMPlaybackRate += 0.015;
                                if (!isAccelerating) {
                                    speed = baseGameSpeed;
                                    bgm.playbackRate = currentBaseBGMPlaybackRate;
                                }
                            }

                            // Change background every 10 score
                            if (score % 10 === 0) {
                                backgroundIndex = (backgroundIndex + 1) % backgrounds.length;
                                game.style.opacity = 0; // Start fade out
                                setTimeout(() => { // Short delay before changing image
                                    game.style.backgroundImage = `url('${backgrounds[backgroundIndex]}')`;
                                    game.style.opacity = 1; // Fade in new background
                                }, 300); // Match CSS transition duration
                            }
                        } else { // Wrong answer
                            combo = 0;
                            updateComboBar();
                            lives--;
                            updateLivesDisplay();
                            updateHearts();
                            seWrong.currentTime = 0;
                            seWrong.volume = 0.5;
                            seWrong.play();
                            flashPlayerRed();

                            if (lives <= -1) { // Game Over
                                fadeOutBGM();
                                const rankings = updateRanking(distance, isAdultMode, selectedSkin);
                                showRanking(rankings);
                                return;
                            }
                        }
                        // After an answer (correct or wrong), spawn next challenge after a delay
                        setTimeout(() => {
                            isSpawning = false;
                            spawnChallenge();
                        }, 4 * 1000 / baseGameSpeed); // Delay scales with speed
                    }

                    // Remove obstacle if it goes off-screen without being hit
                    if (currentObstaclePos < -obstacleVisualWidth && obstacle.parentNode === game) {
                        clearInterval(obstacleMoveInterval);
                        game.removeChild(obstacle);

                        // If the correct obstacle went off-screen without being answered
                        if (!hasAnswered && i === correctLaneIndex) { 
                            combo = 0;
                            updateComboBar();
                            lives--;
                            updateLivesDisplay();
                            updateHearts();
                            seWrong.currentTime = 0;
                            seWrong.volume = 0.5;
                            seWrong.play();
                            flashPlayerRed();

                            if (lives <= -1) { // Game Over
                                fadeOutBGM();
                                const rankings = updateRanking(distance, isAdultMode, selectedSkin);
                                showRanking(rankings);
                                return;
                            }
                            // Spawn next challenge after missing
                            setTimeout(() => {
                                isSpawning = false;
                                spawnChallenge();
                            }, 4 * 1000 / baseGameSpeed); 
                        } else if (!hasAnswered) {
                            // If player hasn't answered yet and any obstacle went off-screen,
                            // we need to ensure the next challenge spawns eventually.
                            // This case covers incorrect obstacles passing or correct ones being missed.
                            setTimeout(() => {
                                isSpawning = false;
                                spawnChallenge();
                            }, 4 * 1000 / baseGameSpeed); 
                        }
                    }
                }, 20); // Obstacle movement interval
            });
        }


        // -------------------------------------------------------------
        // ãƒ©ã‚¤ãƒ•è¡¨ç¤º & ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ (Lives Display & Damage Effect)
        // -------------------------------------------------------------
        function updateLivesDisplay() {
            livesDisplay.textContent = 'â¤ï¸'.repeat(Math.max(0, lives));
        }

        function updateHearts() { // Duplicate of updateLivesDisplay, kept for compatibility with existing calls
            livesDisplay.textContent = 'â¤ï¸'.repeat(Math.max(0, lives));
        }

        function flashPlayerRed(times = 3, interval = 100) {
            let count = 0;
            const flash = () => {
                // Alternates between a dark filter and no filter
                player.style.filter = count % 2 === 0 ? "brightness(0.4)" : "none";
                count++;
                if (count < times * 2) {
                    setTimeout(flash, interval);
                } else {
                    player.style.filter = "none"; // Ensure filter is reset at the end
                }
            };
            flash();
        }

        // -------------------------------------------------------------
        // ã‚³ãƒ³ãƒœã‚²ãƒ¼ã‚¸ (Combo Bar)
        // -------------------------------------------------------------
        function updateComboBar() {
            const bar = document.getElementById("combo-bar");
            const percentage = Math.min((combo % 10) * 10, 100); // Fills up to 100% for 10 combos
            bar.style.width = `${percentage}%`;
        }

        // -------------------------------------------------------------
        // ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ  (Ranking System)
        // -------------------------------------------------------------
        function getRankings(isAdult) {
            const key = isAdult ? 'adultRankings' : 'normalRankings';
            return JSON.parse(localStorage.getItem(key) || '[]');
        }

        function saveRankings(rankings, isAdult) {
            const key = isAdult ? 'adultRankings' : 'normalRankings';
            localStorage.setItem(key, JSON.stringify(rankings));
        }

        function updateRanking(newDistance, isAdult, playerSkin) {
            let rankings = getRankings(isAdult);
            // Store score as an integer to prevent floating point issues with sorting
            rankings.push({ score: Math.floor(newDistance), skin: playerSkin }); 
            rankings.sort((a, b) => b.score - a.score); // Sort descending by score
            rankings = rankings.slice(0, 10); // Keep top 10 (or desired number)
            saveRankings(rankings, isAdult);
            return rankings;
        }

        function showRanking(rankings) {
            const modal = document.getElementById("ranking-modal");
            const finalScore = document.getElementById("final-score");
            const rankingList = document.getElementById("ranking-list");

            const myScore = Math.floor(distance);
            // Find player's rank. If not found (e.g., list is empty), it will be -1.
            const myRank = rankings.findIndex(entry => entry.score === myScore && entry.skin === selectedSkin) + 1; 
            
            // Adjusted final score text
            finalScore.textContent = `ã‚ãªãŸã®ã‚¹ã‚³ã‚¢: ${myScore}m ${myRank > 0 ? `ï¼ˆ${myRank}ä½ï¼‰` : ''}`;

            rankingList.innerHTML = ""; // Clear previous list
            const medals = ["ğŸ¥‡", "ğŸ¥ˆ", "ğŸ¥‰"];

            // Display top 7 or fewer if less are ranked
            rankings.slice(0, 7).forEach((entry, i) => {
                const li = document.createElement("li");
                
                // Add medal or rank number
                const rankText = document.createElement("span");
                if (i < medals.length) {
                    rankText.textContent = `${medals[i]} ${entry.score}m`;
                } else {
                    rankText.textContent = `${i + 1}ä½: ${entry.score}m`;
                }

                // Skin image
                const img = document.createElement("img");
                img.src = entry.skin || "default.gif"; // Fallback in case skin is missing
                img.alt = "skin";
                // Scale image based on current game area width, similar to player/obstacle
                img.style.width = `${game.offsetWidth * (18 / 800)}px`; // å¤‰æ›´: 32pxã‹ã‚‰24pxã«ç¸®å°
                img.style.height = `${game.offsetWidth * (18 / 800)}px`; // Keep it square, å¤‰æ›´: 32pxã‹ã‚‰24pxã«ç¸®å°
                img.style.verticalAlign = "middle";
                img.style.marginLeft = `${game.offsetWidth * (4 / 800)}px`; // å¤‰æ›´: 8pxã‹ã‚‰6pxã«ç¸®å°
                img.style.borderRadius = `${game.offsetWidth * (3 / 800)}px`; // å¤‰æ›´: 5pxã‹ã‚‰4pxã«ç¸®å°

                li.appendChild(rankText);
                li.appendChild(img);
                rankingList.appendChild(li);
            });

            modal.style.display = "block";
            document.getElementById("overlay").style.display = "block"; // Show overlay
        }

        // -------------------------------------------------------------
        // BGMãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ (BGM Fade Out)
        // -------------------------------------------------------------
        function fadeOutBGM() {
            let volume = bgm.volume;
            const fade = setInterval(() => {
                if (volume > 0.01) {
                    volume -= 0.01;
                    bgm.volume = volume;
                } else {
                    clearInterval(fade);
                    bgm.pause();
                    bgm.currentTime = 0; // Reset BGM time after fade
                    bgm.volume = 0.1; // Reset volume for next play
                }
            }, 50);
        }

        // -------------------------------------------------------------
        // åˆæœŸåŒ–å‡¦ç† (Initialization)
        // -------------------------------------------------------------
        // Initial setup on page load
        document.addEventListener('DOMContentLoaded', () => {
            selectSkin(selectedSkin); // Apply border to default skin
            updateLivesDisplay(); // Initialize lives display
            updateComboBar(); // Initialize combo bar
            // updateLanePositions will be called on game start, as game.offsetHeight is 0 before display block
        });

        // Add a resize event listener to update lane positions
        window.addEventListener('resize', () => {
            updateLanePositions(); // Recalculate lane positions when window is resized
            selectSkin(selectedSkin); // Reapply border for selected skin (in case vw changes affected it)
        });
    </script>
</body>
</html>
